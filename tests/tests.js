// @ts-check

/** TQR Tests
 * This file does two things. First, it manages test data. Seconod, it uses that test data
 * to test the TQR client (app.js).
 *
 * DATA
 * There are two kinds of test data.
 * TestData is a database with existing connections in the Redis Streams database.
 * The connection consists in a country, nonce, and userID.
 * A nonce is a string key used by Redis Streams to return a userID.
 * The NONCES enum can have any other keys used to create new connections and to test
 * that the client doesn't duplicated keys in the Stream (note: duplicate keys are
 * permissible in Redis Stream, but this breaks referntial integrity for the client).
 * The AGENCY enum is populated with NONCE combinations used to setup a connection.
 *
 * TESTS
 * The most basic test adds an entry in the Streams database returning the Stream ID
 * (which is a unique timestamp) that provides the client with a userID.
 * The test completes after adding the new entry to the TestData database.
 *
 * Subsequent tests are taken from the TestData database.
 *
 * @see app.js
 */
const app = require('../src/app');
const {
  binaryHas,
  error,
  log,
  jLog,
  notice,
  isEmpty,
  reducePairsToObject,
  success,
  table,
  warn,
  clc,
} = require('../srv/utils/helpers');

//#region Database
// very cool json db: https://belphemur.github.io/node-json-db/#appending-in-array

// @ts-ignore
const { JsonDB } = require('node-json-db');
// @ts-ignore
const { Config } = require('node-json-db/dist/lib/JsonDBConfig');
// when configuring the db, be sure to start with the current dir name,
// otherwise, the data file goes to the parent folder
// or if you start the string with '/' the file will be on the PC's root dir
const db = new JsonDB(new Config('tests/TestData', true, true, '/'));

const testData = db.getData('/');
const firstTest = isEmpty(testData);
jLog(testData, `${firstTest ? 'Adding first test' : 'TestData.json :>>'}`);
log();

const pushNewConnection = (conn) => {
  jLog(conn, 'conn :>>');
  db.push('/connections[]', conn, true);
  jLog(db.getData('/'), 'TestData :>>');
  log();
};
//#endregion Database

const keyDelimiter = '@';
// A nonce is a Named-Once string locally unique (at least at country level) that identifies an AGENCY.
// An AGENCY is any legal entity participating in Anonymous Engagement such as TQR.
// An AGENT is any authorized person in an AGENCY (e.g., a store manager).
// You can string NONCES together with the keyDelimiter to make a key for Redis Streams
const NONCES = {
  PopsBbqTruck: 'Pops BBQ Truck',
  BendTruck: 'Bend Truck',
  FoodRepublic: 'Food Republic',
  BreadTalk: 'Bread Talk',
  SuntecCity: 'Suntec City',
};
// Agency is a keyDelimiter-delimited string of Agents beginning with a Pricipal
const AGENCY = {
  PopsBbqTruck: NONCES.PopsBbqTruck,
  PopsBbq_BendTruck: `${NONCES.PopsBbqTruck}${keyDelimiter}${NONCES.BendTruck}`,
  FoodRepublic: NONCES.FoodRepublic,
  FoodRepublic_SuntecCity: `${NONCES.FoodRepublic}${keyDelimiter}${NONCES.SuntecCity}`,
};

const connection = {
  // country with jurisdiction
  country: '',
  // string key identifying entity in Redis Streams
  nonce: '',
  // generated by Server, stored to and used from TestData
  userID: '',
};

if (firstTest) {
  // TODO Set country to wherever you want to test TQR
  connection.country = 'sg';
  // TODO setup your own entity enum
  connection.nonce = AGENCY.FoodRepublic;
} else {
  // TODO Randomize selection of connection
  const agency = 'Food Republic';
  const idx = db.getIndex('/connections', agency, 'nonce');
  log(`index for ${agency}: ${idx}`);
  const conn = db.getData(`/connections[${idx}]`);
  jLog(conn, `${agency} :>>`);
  connection.country = conn.country;
  connection.nonce = conn.nonce;
  connection.userID = conn.userID;
}

const STEPS = {
  null: 0,
  onAddConnection: 1,
  getConnections: 1 << 1,
  addPromotion: 1 << 2,
  getPromotions: 1 << 3,
};

const TESTS = {
  onboard: STEPS.onAddConnection,
  getConnections: STEPS.getConnections,
  addPromo: STEPS.addPromotion,
  getPromos: STEPS.getPromotions,
};

const TEST = TESTS.getConnections;

notice('Connecting...');
// connect to server and to Redis
// then run tests
app.connectMe().then((socket) => test());

const test = () => {
  notice('Testing...');
  if (binaryHas(TEST, TESTS.onboard)) {
    log('TEST: onAddConnection()...');
    if (!firstTest) {
      warn('This version does not permit addConnection after firstTest');
      return;
    }
    app
      .onAddConnection(connection)
      .then((newConn) => pushNewConnection(newConn))
      .catch((e) => error(jLog(e, 'Error in onAddConnection() chain')));
  }

  if (binaryHas(TEST, TESTS.getConnections)) {
    console.log('getConnections()...');
    app.getConnections(connection.country);
  }

  if (binaryHas(TEST, TESTS.addPromo)) {
    console.log('addPromo()...');
    app.addPromo({
      name: 'Get Sauced at Pops',
      url: 'https://www.popsouthernbbq.com/menu',
    });
  }

  if (binaryHas(TEST, TESTS.getPromotions)) {
    console.log('calling getPromotions()...');
    app.getPromotions();
  }
};
